import { useState, useEffect } from 'react';
import { collection, addDoc, updateDoc, deleteDoc, doc, onSnapshot, serverTimestamp } from 'firebase/firestore';
import { db } from '@/lib/firebase';

export interface Exploit {
  id?: string;
  name: string;
  description: string;
  imageUrl: string;
  downloads: string;
  platforms: string[];
  isVerified?: boolean;
  isPopular?: boolean;
  gradient?: string;
  downloadUrl?: string;
  createdAt?: any;
  updatedAt?: any;
}

export function useFirebaseExploits() {
  const [exploits, setExploits] = useState<Exploit[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const unsubscribe = onSnapshot(
      collection(db, 'exploits'),
      (snapshot) => {
        try {
          const exploitsData = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
          })) as Exploit[];
          
          // Sort by creation date, newest first
          exploitsData.sort((a, b) => {
            if (!a.createdAt || !b.createdAt) return 0;
            return b.createdAt.toMillis() - a.createdAt.toMillis();
          });
          
          setExploits(exploitsData);
          setError(null);
        } catch (err) {
          console.error('Error fetching exploits:', err);
          setError('Erreur lors du chargement des exploits');
        } finally {
          setLoading(false);
        }
      },
      (err) => {
        console.error('Firestore error:', err);
        setError('Erreur de connexion Firebase');
        setLoading(false);
      }
    );

    return () => unsubscribe();
  }, []);

  const addExploit = async (exploit: Omit<Exploit, 'id' | 'createdAt' | 'updatedAt'>) => {
    try {
      const docRef = await addDoc(collection(db, 'exploits'), {
        ...exploit,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      });
      
      return { id: docRef.id, ...exploit };
    } catch (error) {
      console.error('Error adding exploit:', error);
      throw new Error('Erreur lors de l\'ajout de l\'exploit');
    }
  };

  const updateExploit = async (id: string, updates: Partial<Exploit>) => {
    try {
      await updateDoc(doc(db, 'exploits', id), {
        ...updates,
        updatedAt: serverTimestamp()
      });
    } catch (error) {
      console.error('Error updating exploit:', error);
      throw new Error('Erreur lors de la mise Ã  jour de l\'exploit');
    }
  };

  const deleteExploit = async (id: string) => {
    try {
      await deleteDoc(doc(db, 'exploits', id));
    } catch (error) {
      console.error('Error deleting exploit:', error);
      throw new Error('Erreur lors de la suppression de l\'exploit');
    }
  };

  return {
    exploits,
    loading,
    error,
    addExploit,
    updateExploit,
    deleteExploit
  };
}
